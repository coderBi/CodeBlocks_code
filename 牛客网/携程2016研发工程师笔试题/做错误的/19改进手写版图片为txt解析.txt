①： 这个文件之所以存在，是因为个人会看之前的拍照手写版的这个题的解析有些不是很清楚，
而且自己重新书写有温故知新的效果。

②：题目最关键点是浮点与double的内存结构：
	浮点占32位，高位第一位是符号位，紧接着8位是阶码，剩下的下面的23位是尾数
	double差不多，一共64位，但是阶码是11位，剩下的是尾数。
③： 另一个知识点是 float double 打印的时候入栈的都是double，所以这题打印的b c 在
	printf从右到左入栈的是 （double）c  (double) b (int) a

-----------
具体题目分析：
	int a; float b, c;
	scanf("%2d%3f%4f",&a,&b,&c);
--这两句代码，结合输入数字9876543210， 得到 a=98 b=765.0f c=4321.0f
	printf("%d%d%f", a,b,c);
--这句代码，首先printf语句将 c b a 依次入栈。这里有一个注意点是b c 两个float类型
的入栈，会统一转换成double再入栈。其次还有一个注意点，就是Windows系统下，小头朝上
--（double）4321.0二进制科学计数法表示： 1.0.....(尾数有11位) * 2^12。其内存中实际
情况是：
	低32位： 全0
	高32位从高位到低位： 符号位0  阶码12+1023  部分尾数（20位），尾数只有前11尾不是0
--（double）765.0 二进制科学计数法表示： 1.1...(尾数有8位) * 2^9 这样。
跟先入栈的c一样，b在内存中二进制表示：
	低32位： 全0
	高32位： 符号位0  阶码9+1023  部分尾数（20位），尾数只有前8尾不是0
---通过上面的分析，printf输出之前入栈的内存情况（从栈顶往下）：
四字节：９８
四字节：０
四字节：低位有11个０
四字节：０
四字节：低位有8个０
-----打印：
	%d: 出栈 4 字节，打印处 98
	%d:出栈 4 字节， 打印0
	%f：出栈8字节，因为高四字节是0，所以表示为 * 2^-1023。 这是一个很小的数，打印结果是 0.000000(默认保留6位)